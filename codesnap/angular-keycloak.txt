Project Directory: angular-keycloak
Total Files Analyzed: 56
Total Size: 0.10 MB
Date: 2025-03-27T10:56:55.091Z

Token counts and costs by model:
   GPT-3.5: 23.5K tokens → $0.0353
   GPT-4:   23.5K tokens → $0.7059
   Claude:  23.5K tokens → $0.3530
   LLaMA 2: 25.9K tokens → $0.0518

Directory structure:
├── .angular/
│   └── vite-root/
│       └── browser/
│           └── assets/
│               └── silent-check-sso.html
├── src/
│   ├── app/
│   │   ├── auth/
│   │   │   ├── auth.guard.ts
│   │   │   ├── auth.interceptor.ts
│   │   │   ├── auth.service.spec.ts
│   │   │   ├── auth.service.ts
│   │   │   └── keycloak-init.ts
│   │   ├── dashboard/
│   │   │   ├── dashboard.component.html
│   │   │   ├── dashboard.component.scss
│   │   │   ├── dashboard.component.spec.ts
│   │   │   └── dashboard.component.ts
│   │   ├── home/
│   │   │   ├── home.component.html
│   │   │   ├── home.component.scss
│   │   │   ├── home.component.spec.ts
│   │   │   └── home.component.ts
│   │   ├── keycloak-diagnostic/
│   │   │   ├── keycloak-diagnostic.component.html
│   │   │   ├── keycloak-diagnostic.component.scss
│   │   │   ├── keycloak-diagnostic.component.spec.ts
│   │   │   └── keycloak-diagnostic.component.ts
│   │   ├── login/
│   │   │   ├── login.component.html
│   │   │   ├── login.component.scss
│   │   │   ├── login.component.spec.ts
│   │   │   └── login.component.ts
│   │   ├── profile/
│   │   │   ├── profile.component.html
│   │   │   ├── profile.component.scss
│   │   │   ├── profile.component.spec.ts
│   │   │   └── profile.component.ts
│   │   ├── services/
│   │   │   ├── keycloak-error-handler.service.spec.ts
│   │   │   ├── keycloak-error-handler.service.ts
│   │   │   ├── keycloak-wrapper.service.spec.ts
│   │   │   └── keycloak-wrapper.service.ts
│   │   ├── unauthorized/
│   │   │   ├── unauthorized.component.html
│   │   │   ├── unauthorized.component.scss
│   │   │   ├── unauthorized.component.spec.ts
│   │   │   └── unauthorized.component.ts
│   │   ├── app.component.scss
│   │   ├── app.component.spec.ts
│   │   ├── app.component.ts
│   │   ├── app.config.server.ts
│   │   ├── app.config.ts
│   │   ├── app.routes.server.ts
│   │   └── app.routes.ts
│   ├── assets/
│   │   └── silent-check-sso.html
│   ├── index.html
│   ├── main.server.ts
│   ├── main.ts
│   ├── server.ts
│   └── styles.scss
├── .editorconfig
├── .gitignore
├── .postcssrc.json
├── angular.json
├── package.json
├── README.md
├── tsconfig.app.json
├── tsconfig.json
└── tsconfig.spec.json

================================================
File: README.md
================================================
# AngularKeycloak

This project was generated using [Angular CLI](https://github.com/angular/angular-cli) version 19.1.8.

## Development server

To start a local development server, run:

```bash
ng serve
```

Once the server is running, open your browser and navigate to `http://localhost:4200/`. The application will automatically reload whenever you modify any of the source files.

## Code scaffolding

Angular CLI includes powerful code scaffolding tools. To generate a new component, run:

```bash
ng generate component component-name
```

For a complete list of available schematics (such as `components`, `directives`, or `pipes`), run:

```bash
ng generate --help
```

## Building

To build the project run:

```bash
ng build
```

This will compile your project and store the build artifacts in the `dist/` directory. By default, the production build optimizes your application for performance and speed.

## Running unit tests

To execute unit tests with the [Karma](https://karma-runner.github.io) test runner, use the following command:

```bash
ng test
```

## Running end-to-end tests

For end-to-end (e2e) testing, run:

```bash
ng e2e
```

Angular CLI does not come with an end-to-end testing framework by default. You can choose one that suits your needs.

## Additional Resources

For more information on using the Angular CLI, including detailed command references, visit the [Angular CLI Overview and Command Reference](https://angular.dev/tools/cli) page.


================================================
File: .angular/vite-root/browser/assets/silent-check-sso.html
================================================
<html>
  <body>
    <script>
      parent.postMessage(location.href, location.origin);
    </script>
  </body>
</html>

================================================
File: .editorconfig
================================================
# Editor configuration, see https://editorconfig.org
root = true

[*]
charset = utf-8
indent_style = space
indent_size = 2
insert_final_newline = true
trim_trailing_whitespace = true

[*.ts]
quote_type = single
ij_typescript_use_double_quotes = false

[*.md]
max_line_length = off
trim_trailing_whitespace = false


================================================
File: .gitignore
================================================
# See https://docs.github.com/get-started/getting-started-with-git/ignoring-files for more about ignoring files.

# Compiled output
/dist
/tmp
/out-tsc
/bazel-out

# Node
/node_modules
npm-debug.log
yarn-error.log

# IDEs and editors
.idea/
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# Visual Studio Code
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
.history/*

# Miscellaneous
/.angular/cache
.sass-cache/
/connect.lock
/coverage
/libpeerconnection.log
testem.log
/typings

# System files
.DS_Store
Thumbs.db


================================================
File: .postcssrc.json
================================================
{
  "plugins": {
    "@tailwindcss/postcss": {}
  }
}


================================================
File: angular.json
================================================
{
  "$schema": "./node_modules/@angular/cli/lib/config/schema.json",
  "version": 1,
  "newProjectRoot": "projects",
  "projects": {
    "angular-keycloak": {
      "projectType": "application",
      "schematics": {
        "@schematics/angular:component": {
          "style": "scss"
        }
      },
      "root": "",
      "sourceRoot": "src",
      "prefix": "app",
      "architect": {
        "build": {
          "builder": "@angular-devkit/build-angular:application",
          "options": {
            "outputPath": "dist/angular-keycloak",
            "index": "src/index.html",
            "browser": "src/main.ts",
            "polyfills": ["zone.js"],
            "tsConfig": "tsconfig.app.json",
            "inlineStyleLanguage": "scss",
            "assets": [
              "src/favicon.ico",
              {
                "glob": "**/*",
                "input": "src/assets",
                "output": "/assets/"
              }
            ],
            "styles": ["src/styles.scss"],
            "scripts": [],
            "server": "src/main.server.ts",
            "outputMode": "server",
            "ssr": {
              "entry": "src/server.ts"
            }
          },
          "configurations": {
            "production": {
              "budgets": [
                {
                  "type": "initial",
                  "maximumWarning": "500kB",
                  "maximumError": "1MB"
                },
                {
                  "type": "anyComponentStyle",
                  "maximumWarning": "4kB",
                  "maximumError": "8kB"
                }
              ],
              "outputHashing": "all"
            },
            "development": {
              "optimization": false,
              "extractLicenses": false,
              "sourceMap": true
            }
          },
          "defaultConfiguration": "production"
        },
        "serve": {
          "builder": "@angular-devkit/build-angular:dev-server",
          "configurations": {
            "production": {
              "buildTarget": "angular-keycloak:build:production"
            },
            "development": {
              "buildTarget": "angular-keycloak:build:development"
            }
          },
          "defaultConfiguration": "development"
        },
        "extract-i18n": {
          "builder": "@angular-devkit/build-angular:extract-i18n"
        },
        "test": {
          "builder": "@angular-devkit/build-angular:karma",
          "options": {
            "polyfills": ["zone.js", "zone.js/testing"],
            "tsConfig": "tsconfig.spec.json",
            "inlineStyleLanguage": "scss",
            "assets": [
              {
                "glob": "**/*",
                "input": "public"
              }
            ],
            "styles": ["src/styles.scss"],
            "scripts": []
          }
        }
      }
    }
  }
}


================================================
File: package.json
================================================
{
  "name": "angular-keycloak",
  "version": "0.0.0",
  "scripts": {
    "ng": "ng",
    "start": "ng serve",
    "build": "ng build",
    "watch": "ng build --watch --configuration development",
    "test": "ng test",
    "serve:ssr:angular-keycloak": "node dist/angular-keycloak/server/server.mjs"
  },
  "private": true,
  "dependencies": {
    "@angular/animations": "^19.1.0",
    "@angular/common": "^19.1.0",
    "@angular/compiler": "^19.1.0",
    "@angular/core": "^19.1.0",
    "@angular/forms": "^19.2.3",
    "@angular/platform-browser": "^19.1.0",
    "@angular/platform-browser-dynamic": "^19.1.0",
    "@angular/platform-server": "^19.1.0",
    "@angular/router": "^19.1.0",
    "@angular/ssr": "^19.1.8",
    "@tailwindcss/postcss": "^4.0.17",
    "express": "^4.18.2",
    "keycloak-angular": "^19.0.2",
    "keycloak-js": "^26.1.4",
    "postcss": "^8.5.3",
    "rxjs": "~7.8.0",
    "tailwindcss": "^4.0.17",
    "tslib": "^2.3.0",
    "zone.js": "~0.15.0"
  },
  "devDependencies": {
    "@angular-devkit/build-angular": "^19.1.8",
    "@angular/cli": "^19.1.8",
    "@angular/compiler-cli": "^19.1.0",
    "@types/express": "^4.17.17",
    "@types/jasmine": "~5.1.0",
    "@types/node": "^18.18.0",
    "jasmine-core": "~5.5.0",
    "karma": "~6.4.0",
    "karma-chrome-launcher": "~3.2.0",
    "karma-coverage": "~2.2.0",
    "karma-jasmine": "~5.1.0",
    "karma-jasmine-html-reporter": "~2.1.0",
    "typescript": "~5.7.2"
  }
}


================================================
File: src/app/app.component.spec.ts
================================================
import { TestBed } from '@angular/core/testing';
import { AppComponent } from './app.component';

describe('AppComponent', () => {
  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [AppComponent],
    }).compileComponents();
  });

  it('should create the app', () => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.componentInstance;
    expect(app).toBeTruthy();
  });

  it(`should have the 'angular-keycloak' title`, () => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.componentInstance;
    expect(app.title).toEqual('angular-keycloak');
  });

  it('should render title', () => {
    const fixture = TestBed.createComponent(AppComponent);
    fixture.detectChanges();
    const compiled = fixture.nativeElement as HTMLElement;
    expect(compiled.querySelector('h1')?.textContent).toContain('Hello, angular-keycloak');
  });
});


================================================
File: src/app/app.component.ts
================================================
import { CommonModule } from '@angular/common';
import { Component, OnInit, signal } from '@angular/core';
import { Router, RouterLink, RouterOutlet } from '@angular/router';
import { KeycloakService } from 'keycloak-angular';
import { KeycloakProfile } from 'keycloak-js';
import { firstValueFrom } from 'rxjs';
import { KeycloakWrapperService } from './services/keycloak-wrapper.service';

@Component({
  selector: 'app-root',
  standalone: true,
  imports: [CommonModule, RouterOutlet, RouterLink],
  template: `
    <!-- TODO: Add a header with the logo and the login button -->
    <nav class="bg-gray-800 text-white p-4">
      <div class="container mx-auto flex justify-between items-center">
        <div class="flex space-x-4">
          <a routerLink="/" class="hover:text-gray-300">Home</a>
          <a routerLink="/profile" class="hover:text-gray-300">Profile</a>
          <a routerLink="/debug" class="hover:text-gray-300">Debug</a>
        </div>
      </div>
    </nav>
    <div class="container mx-auto p-4">
      <header
        class="flex justify-between items-center mb-6 p-4 bg-white shadow rounded"
      >
        <h1 class="text-2xl font-bold">Angular Keycloak Auth</h1>

        <div class="flex items-center">
          @if (isLoggedIn()) {
          <span class="mr-4">
            Welcome {{ userProfile()?.firstName || 'User' }}
          </span>
          <button
            class="bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded"
            (click)="logout()"
          >
            Logout
          </button>
          } @else {
          <button
            class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded"
            (click)="login()"
          >
            Login
          </button>
          }
        </div>
      </header>

      <main>
        <router-outlet></router-outlet>
      </main>
    </div>
  `,
})
export class AppComponent implements OnInit {
  constructor(
    private keycloak: KeycloakService,
    private keycloakWrapper: KeycloakWrapperService,
    private router: Router
  ) {}
  // Use the wrapper service instead of direct KeycloakService

  // Use signals for reactive state management
  private isLoggedInState = signal<boolean>(false);
  private userProfileState = signal<KeycloakProfile | null>(null);

  // Expose signals as getters
  public isLoggedIn = this.isLoggedInState.asReadonly();
  public userProfile = this.userProfileState.asReadonly();

  public async ngOnInit(): Promise<void> {
    try {
      // The wrapper service handles SSR detection internally
      const isLoggedIn = await firstValueFrom(
        this.keycloakWrapper.isLoggedIn()
      );
      this.isLoggedInState.set(isLoggedIn);

      if (isLoggedIn) {
        const profile = await firstValueFrom(
          this.keycloakWrapper.getUserProfile()
        );
        this.userProfileState.set(profile);
      }
    } catch (error) {
      console.error('Failed to initialize auth status:', error);
    }
  }

  public login(): void {
    this.keycloakWrapper.login();
  }

  public logout(): void {
    this.keycloakWrapper.logout(window.location.origin);
  }
}


================================================
File: src/app/app.config.server.ts
================================================
import { mergeApplicationConfig, ApplicationConfig } from '@angular/core';
import { provideServerRendering } from '@angular/platform-server';
import { provideServerRouting } from '@angular/ssr';
import { appConfig } from './app.config';
import { serverRoutes } from './app.routes.server';

const serverConfig: ApplicationConfig = {
  providers: [
    provideServerRendering(),
    provideServerRouting(serverRoutes)
  ]
};

export const config = mergeApplicationConfig(appConfig, serverConfig);


================================================
File: src/app/app.config.ts
================================================
import { isPlatformBrowser } from '@angular/common';
import {
  HttpInterceptorFn,
  provideHttpClient,
  withFetch,
  withInterceptors,
} from '@angular/common/http';
import {
  APP_INITIALIZER,
  ApplicationConfig,
  ErrorHandler,
  inject,
  PLATFORM_ID,
  provideZoneChangeDetection,
} from '@angular/core';
import {
  provideClientHydration,
  withEventReplay,
} from '@angular/platform-browser';
import { provideRouter } from '@angular/router';
import { KeycloakService } from 'keycloak-angular';
import { routes } from './app.routes';
import { KeycloakErrorHandler } from './services/keycloak-error-handler.service';
import { KeycloakWrapperService } from './services/keycloak-wrapper.service';

// Function to initialize Keycloak
// keycloak-init.ts

export function initializeKeycloak(
  keycloak: KeycloakService
): () => Promise<boolean> {
  return async (): Promise<boolean> => {
    // Check if we're in a browser environment
    const platformId = inject(PLATFORM_ID);
    if (!isPlatformBrowser(platformId)) {
      // Skip Keycloak initialization in SSR mode
      console.log('Skipping Keycloak initialization in server environment');
      return true;
    }

    try {
      console.log('Initializing Keycloak...');

      // Add more detailed logging for initialization
      const startTime = Date.now();

      // Initialize Keycloak with proper configuration and additional logging
      const success = await keycloak.init({
        config: {
          url: 'http://localhost:8080',
          realm: 'ofelwin',
          clientId: 'ofelwin-client-angular',
        },
        initOptions: {
          onLoad: 'check-sso',
          silentCheckSsoRedirectUri:
            window.location.origin + '/assets/silent-check-sso.html',
          checkLoginIframe: false, // Recommended for better performance

          // Add a flow to improve debugging - can be removed in production
          flow: 'standard', // Alternatives: 'implicit', 'hybrid'

          // Add response mode for better compatibility
          responseMode: 'fragment',
        },
        // Configure bearer token handling
        enableBearerInterceptor: true,
        bearerPrefix: 'Bearer',
        bearerExcludedUrls: ['/assets', '/public', '/debug'],
      });

      const endTime = Date.now();
      const initTime = endTime - startTime;

      if (success) {
        console.log(`Keycloak initialization successful (${initTime}ms)`);

        // Log authentication status
        const instance = keycloak.getKeycloakInstance();
        console.log(
          `Authentication status: ${
            instance.authenticated ? 'Authenticated' : 'Not authenticated'
          }`
        );

        if (instance.authenticated) {
          // Log token info (without exposing the full token)
          const tokenExpiry = instance.tokenParsed?.exp
            ? new Date(instance.tokenParsed.exp * 1000).toISOString()
            : 'unknown';

          console.log(`Token expires: ${tokenExpiry}`);
        }
      } else {
        console.warn(
          `Keycloak initialization completed without error but returned false (${initTime}ms)`
        );
      }

      return success;
    } catch (error) {
      console.error('Error initializing Keycloak:', error);

      // Provide more detailed diagnostics based on error type
      if (error instanceof Error) {
        console.error(`Error name: ${error.name}, message: ${error.message}`);

        if (
          error.name === 'NetworkError' ||
          error.message.includes('network')
        ) {
          console.error(
            'Network error detected. Please check if Keycloak server is running and accessible.'
          );
        } else if (error.message.includes('realm')) {
          console.error(
            'Realm error detected. Please verify the realm "ofelwin" exists on the Keycloak server.'
          );
        } else if (error.message.includes('client')) {
          console.error(
            'Client error detected. Please verify the client "ofelwin-client-angular" is properly configured.'
          );
        }

        // Suggest visiting the debug route
        console.info(
          'Consider accessing the /debug route to diagnose Keycloak connection issues.'
        );
      }

      // Return false to indicate initialization failure
      return false;
    }
  };
}

// Custom HTTP interceptor that safely handles Keycloak authentication
const keycloakInterceptor: HttpInterceptorFn = (req, next) => {
  const platformId = inject(PLATFORM_ID);

  // Skip in server environment
  if (!isPlatformBrowser(platformId)) {
    return next(req);
  }

  try {
    // Get the KeycloakService instance
    const keycloakService = inject(KeycloakService);

    // Safely check if Keycloak is initialized
    if (!keycloakService || !keycloakService.getKeycloakInstance) {
      return next(req);
    }

    // Check if the Keycloak instance is initialized and authenticated
    const keycloakInstance = keycloakService.getKeycloakInstance();

    if (keycloakInstance && keycloakInstance.authenticated) {
      // Get the token
      const token = keycloakInstance.token;

      if (token) {
        // Clone the request and add the Authorization header
        const authReq = req.clone({
          headers: req.headers.set('Authorization', `Bearer ${token}`),
        });
        return next(authReq);
      }
    }

    // If not authenticated or no token, proceed with original request
    return next(req);
  } catch (error) {
    console.error('Error in Keycloak interceptor:', error);
    return next(req);
  }
};

export const appConfig: ApplicationConfig = {
  providers: [
    provideZoneChangeDetection({ eventCoalescing: true }),
    provideRouter(routes),
    provideClientHydration(withEventReplay()),

    // Provide Keycloak service
    KeycloakService,

    // Provide our wrapper service
    KeycloakWrapperService,

    // Configure HTTP client with custom interceptor
    provideHttpClient(withFetch(), withInterceptors([keycloakInterceptor])),

    // Initialize Keycloak
    {
      provide: APP_INITIALIZER,
      useFactory: initializeKeycloak,
      multi: true,
      deps: [KeycloakService],
    },

    // Custom error handler for better Keycloak error messages
    {
      provide: ErrorHandler,
      useClass: KeycloakErrorHandler,
    },
  ],
};


================================================
File: src/app/app.routes.server.ts
================================================
import { RenderMode, ServerRoute } from '@angular/ssr';

export const serverRoutes: ServerRoute[] = [
  {
    path: '**',
    renderMode: RenderMode.Prerender
  }
];


================================================
File: src/app/app.routes.ts
================================================
// app.routes.ts
import { Routes } from '@angular/router';
import { AuthGuard } from './auth/auth.guard';
import { HomeComponent } from './home/home.component';
import { LoginComponent } from './login/login.component';
import { ProfileComponent } from './profile/profile.component';

export const routes: Routes = [
  { path: 'login', component: LoginComponent },

  {
    path: '',
    component: HomeComponent,
    canActivate: [AuthGuard],
  },
  {
    path: 'profile',
    component: HomeComponent,
    canActivate: [AuthGuard],
    data: {
      roles: ['user', 'admin'],
    },
  },
  {
    path: 'debug',
    loadComponent: () =>
      import('./keycloak-diagnostic/keycloak-diagnostic.component').then(
        (c) => c.KeycloakDiagnosticComponent
      ),
  },
  {
    path: 'unauthorized',
    loadComponent: () =>
      import('./unauthorized/unauthorized.component').then(
        (c) => c.UnauthorizedComponent
      ),
  },
  {
    path: 'profile',
    component: ProfileComponent,
    canActivate: [AuthGuard],
  },
  {
    path: '**',
    redirectTo: '',
  },
];


================================================
File: src/app/auth/auth.guard.ts
================================================
// auth.guard.ts
import { Injectable, inject } from '@angular/core';
import {
  ActivatedRouteSnapshot,
  CanActivateFn,
  Router,
  RouterStateSnapshot,
  UrlTree,
} from '@angular/router';
import { Observable, map, take } from 'rxjs';
import { AuthService } from './auth.service';

@Injectable({
  providedIn: 'root',
})
export class AuthGuard {
  private authService = inject(AuthService);
  private router = inject(Router);

  canActivate: CanActivateFn = (
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot
  ): Observable<boolean | UrlTree> => {
    return this.authService.isAuthenticated$.pipe(
      take(1),
      map((isAuthenticated) => {
        if (isAuthenticated) {
          return true;
        }

        // Redirect to login page with return URL
        return this.router.createUrlTree(['/login'], {
          queryParams: { returnUrl: state.url },
        });
      })
    );
  };
}

// Export the canActivate function for use in routes
export const canActivateAuth: CanActivateFn = (
  route: ActivatedRouteSnapshot,
  state: RouterStateSnapshot
) => {
  return inject(AuthGuard).canActivate(route, state);
};


================================================
File: src/app/auth/auth.interceptor.ts
================================================
// auth.interceptor.ts
import {
  HttpErrorResponse,
  HttpEvent,
  HttpHandler,
  HttpInterceptor,
  HttpRequest,
} from '@angular/common/http';
import { Injectable } from '@angular/core';
import { BehaviorSubject, Observable, throwError } from 'rxjs';
import { catchError, filter, finalize, switchMap, take } from 'rxjs/operators';
import { AuthService } from './auth.service.ts.service';

@Injectable()
export class AuthInterceptor implements HttpInterceptor {
  private isRefreshing = false;
  private refreshTokenSubject: BehaviorSubject<string | null> =
    new BehaviorSubject<string | null>(null);

  constructor(private authService: AuthService) {}

  intercept(
    request: HttpRequest<unknown>,
    next: HttpHandler
  ): Observable<HttpEvent<unknown>> {
    // Skip token for auth endpoints
    if (
      request.url.includes('/auth/realms/') &&
      request.url.includes('/protocol/openid-connect/token')
    ) {
      return next.handle(request);
    }

    // Add token to request
    const token = this.authService.getToken();
    if (token) {
      request = this.addToken(request, token);
    }

    return next.handle(request).pipe(
      catchError((error: HttpErrorResponse) => {
        if (error.status === 401) {
          return this.handle401Error(request, next);
        }
        return throwError(() => error);
      })
    );
  }

  private addToken(
    request: HttpRequest<unknown>,
    token: string
  ): HttpRequest<unknown> {
    return request.clone({
      setHeaders: {
        Authorization: `Bearer ${token}`,
      },
    });
  }

  private handle401Error(
    request: HttpRequest<unknown>,
    next: HttpHandler
  ): Observable<HttpEvent<unknown>> {
    if (!this.isRefreshing) {
      this.isRefreshing = true;
      this.refreshTokenSubject.next(null);

      return this.authService.refreshToken().pipe(
        switchMap((response) => {
          this.refreshTokenSubject.next(response.access_token);
          return next.handle(this.addToken(request, response.access_token));
        }),
        catchError((error) => {
          // If refresh fails, logout and redirect to login
          this.authService.logout();
          return throwError(() => error);
        }),
        finalize(() => {
          this.isRefreshing = false;
        })
      );
    } else {
      // Wait for the token to be refreshed
      return this.refreshTokenSubject.pipe(
        filter((token) => token !== null),
        take(1),
        switchMap((token) => {
          return next.handle(this.addToken(request, token as string));
        })
      );
    }
  }
}


================================================
File: src/app/auth/auth.service.spec.ts
================================================
import { TestBed } from '@angular/core/testing';

import { AuthServiceTsService } from './auth.service.ts.service';

describe('AuthServiceTsService', () => {
  let service: AuthServiceTsService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(AuthServiceTsService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});


================================================
File: src/app/auth/auth.service.ts
================================================
// auth.service.ts
import { isPlatformBrowser } from '@angular/common';
import {
  HttpClient,
  HttpErrorResponse,
  HttpHeaders,
} from '@angular/common/http';
import { Injectable, PLATFORM_ID, inject } from '@angular/core';
import { Router } from '@angular/router';
import { BehaviorSubject, Observable, throwError } from 'rxjs';
import { catchError, tap } from 'rxjs/operators';

interface KeycloakConfig {
  url: string;
  realm: string;
  clientId: string;
}

interface AuthResponse {
  access_token: string;
  refresh_token: string;
  expires_in: number;
  refresh_expires_in: number;
  token_type: string;
  session_state: string;
  scope: string;
}

interface UserCredentials {
  username: string;
  password: string;
}

@Injectable({
  providedIn: 'root',
})
export class AuthService {
  private http = inject(HttpClient);
  private router = inject(Router);
  private platformId = inject(PLATFORM_ID);

  private keycloakConfig: KeycloakConfig = {
    url: 'http://localhost:8080',
    realm: 'ofelwin',
    clientId: 'ofelwin-client-angular',
  };

  private tokenUrl: string;
  private isAuthenticatedSubject = new BehaviorSubject<boolean>(
    this.hasValidToken()
  );
  public isAuthenticated$ = this.isAuthenticatedSubject.asObservable();

  constructor() {
    this.tokenUrl = `${this.keycloakConfig.url}/auth/realms/${this.keycloakConfig.realm}/protocol/openid-connect/token`;
  }

  login(credentials: UserCredentials): Observable<AuthResponse> {
    const body = new URLSearchParams();
    body.set('client_id', this.keycloakConfig.clientId);
    body.set('username', credentials.username);
    body.set('password', credentials.password);
    body.set('grant_type', 'password');

    const headers = new HttpHeaders({
      'Content-Type': 'application/x-www-form-urlencoded',
    });

    return this.http
      .post<AuthResponse>(this.tokenUrl, body.toString(), { headers })
      .pipe(
        tap((response: AuthResponse) => {
          this.storeTokens(response);
          this.isAuthenticatedSubject.next(true);
        }),
        catchError(this.handleError)
      );
  }

  logout(): void {
    if (isPlatformBrowser(this.platformId)) {
      localStorage.removeItem('access_token');
      localStorage.removeItem('refresh_token');
      localStorage.removeItem('token_expires_at');
    }
    this.isAuthenticatedSubject.next(false);
    this.router.navigate(['/login']);
  }

  refreshToken(): Observable<AuthResponse> {
    if (!isPlatformBrowser(this.platformId)) {
      return throwError(() => new Error('Cannot refresh token during SSR'));
    }

    const refreshToken = localStorage.getItem('refresh_token');

    if (!refreshToken) {
      return throwError(() => new Error('No refresh token available'));
    }

    const body = new URLSearchParams();
    body.set('client_id', this.keycloakConfig.clientId);
    body.set('refresh_token', refreshToken);
    body.set('grant_type', 'refresh_token');

    const headers = new HttpHeaders({
      'Content-Type': 'application/x-www-form-urlencoded',
    });

    return this.http
      .post<AuthResponse>(this.tokenUrl, body.toString(), { headers })
      .pipe(
        tap((response: AuthResponse) => {
          this.storeTokens(response);
          this.isAuthenticatedSubject.next(true);
        }),
        catchError((error) => {
          this.logout();
          return this.handleError(error);
        })
      );
  }

  getToken(): string | null {
    if (!isPlatformBrowser(this.platformId)) {
      return null;
    }

    const token = localStorage.getItem('access_token');
    const expiresAt = localStorage.getItem('token_expires_at');

    if (!token || !expiresAt) {
      return null;
    }

    // Check if token is expired
    if (new Date().getTime() > parseInt(expiresAt, 10)) {
      // Token expired, try to refresh it
      this.refreshToken().subscribe();
      return null;
    }

    return token;
  }

  private storeTokens(response: AuthResponse): void {
    if (!isPlatformBrowser(this.platformId)) {
      return;
    }

    const expiresAt = new Date().getTime() + response.expires_in * 1000;

    localStorage.setItem('access_token', response.access_token);
    localStorage.setItem('refresh_token', response.refresh_token);
    localStorage.setItem('token_expires_at', expiresAt.toString());
  }

  private hasValidToken(): boolean {
    if (!isPlatformBrowser(this.platformId)) {
      return false;
    }

    const token = localStorage.getItem('access_token');
    const expiresAt = localStorage.getItem('token_expires_at');

    if (!token || !expiresAt) {
      return false;
    }

    return new Date().getTime() < parseInt(expiresAt, 10);
  }

  private handleError(error: HttpErrorResponse): Observable<never> {
    let errorMessage = 'Unknown error occurred';

    if (error.error instanceof ErrorEvent) {
      // Client-side error
      errorMessage = `Error: ${error.error.message}`;
    } else {
      // Server-side error
      if (error.status === 400 || error.status === 401) {
        errorMessage = 'Invalid username or password';
      } else if (error.status === 0) {
        errorMessage = 'Cannot connect to server, please try again later';
      } else {
        errorMessage = `Error Code: ${error.status}, Message: ${error.message}`;
      }
    }

    console.error(errorMessage);
    return throwError(() => new Error(errorMessage));
  }
}


================================================
File: src/app/auth/keycloak-init.ts
================================================
import { KeycloakService } from 'keycloak-angular';
//ko lien quan den button login
export function initializeKeycloak(
  keycloak: KeycloakService
): () => Promise<boolean> {
  return async (): Promise<boolean> => {
    // Check if we're in a browser environment
    if (typeof window === 'undefined') {
      // Skip Keycloak initialization in SSR mode
      console.log('Skipping Keycloak initialization in server environment');
      return true;
    }

    try {
      // Initialize Keycloak with proper configuration
      return await keycloak.init({
        config: {
          url: 'http://localhost:8080',
          realm: 'ofelwin',
          clientId: 'ofelwin-client-angular',
        },
        initOptions: {
          onLoad: 'check-sso',
          silentCheckSsoRedirectUri:
            window.location.origin + '/assets/silent-check-sso.html',
          checkLoginIframe: false, // Recommended for better performance
        },
        // Configure bearer token handling
        enableBearerInterceptor: true,
        bearerPrefix: 'Bearer',
        bearerExcludedUrls: ['/assets', '/public'],
      });
    } catch (error) {
      console.error('Error initializing Keycloak:', error);
      return false;
    }
  };
}


================================================
File: src/app/dashboard/dashboard.component.html
================================================
<p>dashboard works!</p>


================================================
File: src/app/dashboard/dashboard.component.spec.ts
================================================
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { DashboardComponent } from './dashboard.component';

describe('DashboardComponent', () => {
  let component: DashboardComponent;
  let fixture: ComponentFixture<DashboardComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [DashboardComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(DashboardComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});


================================================
File: src/app/dashboard/dashboard.component.ts
================================================
// dashboard.component.ts
import { CommonModule } from '@angular/common';
import { Component, inject } from '@angular/core';
import { AuthService } from '../auth/auth.service.ts.service';

@Component({
  selector: 'app-dashboard',
  standalone: true,
  imports: [CommonModule],
  template: `
    <div class="min-h-screen bg-gray-50">
      <nav class="bg-white shadow">
        <div class="mx-auto max-w-7xl px-4 sm:px-6 lg:px-8">
          <div class="flex h-16 justify-between">
            <div class="flex flex-1 items-center justify-between">
              <div class="flex flex-shrink-0 items-center">
                <h1 class="text-xl font-bold">Dashboard</h1>
              </div>
              <div>
                <button
                  (click)="logout()"
                  class="rounded-md bg-blue-600 px-3 py-2 text-sm font-medium text-white hover:bg-blue-700"
                >
                  Logout
                </button>
              </div>
            </div>
          </div>
        </div>
      </nav>

      <div class="mx-auto max-w-7xl py-6 sm:px-6 lg:px-8">
        <div class="px-4 py-6 sm:px-0">
          <div
            class="rounded-lg border-4 border-dashed border-gray-200 p-4 min-h-96"
          >
            <h2 class="text-lg font-medium mb-4">Welcome to your Dashboard</h2>
            <p>
              You have successfully logged in. This is a protected route that
              requires authentication.
            </p>
          </div>
        </div>
      </div>
    </div>
  `,
  styles: [],
})
export class DashboardComponent {
  private authService = inject(AuthService);

  logout(): void {
    this.authService.logout();
  }
}


================================================
File: src/app/home/home.component.html
================================================
<p>home works!</p>


================================================
File: src/app/home/home.component.spec.ts
================================================
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { HomeComponent } from './home.component';

describe('HomeComponent', () => {
  let component: HomeComponent;
  let fixture: ComponentFixture<HomeComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [HomeComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(HomeComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});


================================================
File: src/app/home/home.component.ts
================================================
import { CommonModule } from '@angular/common';
import { Component, OnInit, inject, signal } from '@angular/core';
import { KeycloakProfile } from 'keycloak-js';
import { firstValueFrom } from 'rxjs';
import { KeycloakWrapperService } from '../services/keycloak-wrapper.service';

@Component({
  selector: 'app-home',
  standalone: true,
  imports: [CommonModule],
  template: `
    <div class="p-6 max-w-md mx-auto bg-white rounded-xl shadow-md">
      <h2 class="text-xl font-medium text-black mb-4">
        Welcome to Your Dashboard
      </h2>

      @if (loading()) {
      <div class="p-4 text-blue-800 bg-blue-100 rounded">
        Loading user profile...
      </div>
      } @else if (error()) {
      <div class="p-4 text-red-800 bg-red-100 rounded">
        {{ error() }}
        <button
          class="ml-2 px-3 py-1 bg-red-500 text-white rounded hover:bg-red-600"
          (click)="retry()"
        >
          Retry
        </button>
      </div>
      } @else if (userProfile()) {
      <div class="space-y-3">
        <h3 class="text-lg font-medium text-gray-900">User Profile</h3>

        <div class="flex flex-col space-y-2">
          <div class="flex">
            <span class="font-medium w-28">Username:</span>
            <span>{{ userProfile()?.username }}</span>
          </div>

          <div class="flex">
            <span class="font-medium w-28">Email:</span>
            <span>{{ userProfile()?.email }}</span>
          </div>

          <div class="flex">
            <span class="font-medium w-28">First Name:</span>
            <span>{{ userProfile()?.firstName }}</span>
          </div>

          <div class="flex">
            <span class="font-medium w-28">Last Name:</span>
            <span>{{ userProfile()?.lastName }}</span>
          </div>

          @if (userProfile()?.emailVerified) {
          <div class="mt-2 text-sm text-green-600">Email verified</div>
          } @else {
          <div class="mt-2 text-sm text-red-600">Email not verified</div>
          }
        </div>

        @if (realmRoles().length > 0) {
        <div class="mt-4">
          <h4 class="text-md font-medium text-gray-900">Your Roles</h4>
          <ul class="list-disc pl-5 mt-2">
            @for (role of realmRoles(); track role) {
            <li>{{ role }}</li>
            }
          </ul>
        </div>
        }
      </div>
      } @else {
      <div class="p-4 text-amber-800 bg-amber-100 rounded">
        No user profile available. Please log in.
      </div>
      }
    </div>
  `,
})
export class HomeComponent implements OnInit {
  private keycloakWrapper = inject(KeycloakWrapperService);

  // State management with signals
  userProfile = signal<KeycloakProfile | null>(null);
  realmRoles = signal<string[]>([]);
  loading = signal<boolean>(true);
  error = signal<string | null>(null);

  ngOnInit(): void {
    this.loadUserData();
  }

  async loadUserData(): Promise<void> {
    try {
      this.loading.set(true);
      this.error.set(null);

      // The wrapper service safely handles SSR conditions
      const isLoggedIn = await this.keycloakWrapper.isLoggedIn();

      if (isLoggedIn) {
        const profile = await firstValueFrom(
          this.keycloakWrapper.getUserProfile()
        );
        this.userProfile.set(profile);

        const roles = await firstValueFrom(this.keycloakWrapper.getUserRoles());
        this.realmRoles.set(roles);
      } else {
        // Not an error, just no user is logged in
        this.userProfile.set(null);
        this.realmRoles.set([]);
      }
    } catch (err) {
      console.error('Error loading user data:', err);
      this.error.set('Failed to load user data. Please try again later.');
    } finally {
      this.loading.set(false);
    }
  }

  retry(): void {
    this.loadUserData();
  }
}


================================================
File: src/app/keycloak-diagnostic/keycloak-diagnostic.component.html
================================================
<div class="p-6 max-w-4xl mx-auto bg-white rounded-xl shadow-lg">
  <h2 class="text-2xl font-bold text-gray-900 mb-6">
    Keycloak Connection Troubleshooter
  </h2>

  <!-- Fix Actions -->
  <div class="mb-8 p-4 border rounded-md bg-blue-50">
    <h3 class="text-lg font-semibold text-blue-800 mb-2">Quick Fix Actions</h3>
    <div class="flex flex-wrap gap-2">
      <button
        class="px-3 py-1.5 bg-blue-600 text-white font-medium rounded hover:bg-blue-700"
        (click)="fixSilentCheckSso()"
        [disabled]="ssoFixInProgress()"
      >
        @if (ssoFixInProgress()) {
        <span>Fixing SSO File...</span>
        } @else {
        <span>Fix Silent-Check-SSO</span>
        }
      </button>

      <button
        class="px-3 py-1.5 bg-green-600 text-white font-medium rounded hover:bg-green-700"
        (click)="runAllTests()"
      >
        Run All Tests
      </button>

      <button
        class="px-3 py-1.5 bg-purple-600 text-white font-medium rounded hover:bg-purple-700"
        (click)="clearCache()"
      >
        Clear Browser Cache
      </button>
    </div>

    @if (lastFixMessage()) {
    <div class="mt-3 p-2 rounded bg-gray-100 text-sm">
      {{ lastFixMessage() }}
    </div>
    }
  </div>

  <!-- Connection Status -->
  <div class="mb-6 p-4 border rounded-md">
    <h3 class="font-medium text-lg mb-2">Current Connection Status</h3>
    <div
      class="p-3 rounded-md text-sm"
      [ngClass]="{
        'bg-green-100 text-green-800': isAuthenticated(),
        'bg-yellow-100 text-yellow-800': !isAuthenticated()
      }"
    >
      <div class="grid grid-cols-2 gap-2">
        <div class="font-medium">Connected:</div>
        <div>{{ isConnected() ? "✓" : "✗" }}</div>

        <div class="font-medium">Initialized:</div>
        <div>{{ isInitialized() ? "✓" : "✗" }}</div>

        <div class="font-medium">Authenticated:</div>
        <div>{{ isAuthenticated() ? "✓" : "✗" }}</div>

        @if (tokenExpiry()) {
        <div class="font-medium">Token Expires:</div>
        <div>{{ tokenExpiry() }}</div>
        }
      </div>

      @if (connectionError()) {
      <div class="mt-3 p-2 bg-red-50 text-red-700 rounded">
        Error: {{ connectionError() }}
      </div>
      }
    </div>
  </div>

  <!-- Server Tests -->
  <div class="mb-6">
    <h3 class="font-medium text-lg mb-2">Keycloak Server Tests</h3>
    <div class="space-y-3">
      @for (test of serverTests(); track test.url) {
      <div class="p-3 border rounded-md">
        <div class="flex justify-between items-center">
          <div>
            <span class="font-medium">{{ test.description }}</span>
            <div class="text-xs text-gray-500">{{ test.url }}</div>
          </div>
          <div class="flex items-center">
            @if (test.status === 'pending') {
            <div class="text-blue-600">Testing...</div>
            } @else if (test.status === 'success') {
            <div class="text-green-600">✓ Success</div>
            } @else if (test.status === 'error') {
            <div class="text-red-600">✗ Failed</div>
            } @else {
            <div class="text-gray-400">Not Tested</div>
            }
            <button
              class="ml-2 p-1 text-sm bg-gray-100 hover:bg-gray-200 rounded"
              (click)="runServerTest(test)"
            >
              Test
            </button>
          </div>
        </div>

        @if (test.status === 'error' && test.errorMessage) {
        <div class="mt-2 p-2 bg-red-50 text-sm text-red-700 rounded-md">
          {{ test.errorMessage }}
        </div>
        } @if (test.status === 'success' && test.responseData) {
        <details class="mt-2">
          <summary class="text-sm text-blue-600 cursor-pointer">
            Show Response Data
          </summary>
          <pre
            class="mt-1 p-2 bg-gray-50 text-xs overflow-auto max-h-40 rounded"
            >{{ test.responseData | json }}</pre
          >
        </details>
        }
      </div>
      }
    </div>
  </div>

  <!-- File Checks -->
  <div class="mb-6">
    <h3 class="font-medium text-lg mb-2">Critical Files Check</h3>
    <div class="space-y-3">
      @for (file of fileChecks(); track file.path) {
      <div class="p-3 border rounded-md">
        <div class="flex justify-between items-center">
          <div>
            <span class="font-medium">{{ file.path }}</span>
          </div>
          <div class="flex items-center">
            @if (file.status === 'pending') {
            <div class="text-blue-600">Checking...</div>
            } @else if (file.status === 'success') {
            <div class="text-green-600">✓ Found</div>
            } @else if (file.status === 'error') {
            <div class="text-red-600">✗ Missing</div>
            } @else {
            <div class="text-gray-400">Not Checked</div>
            }
            <button
              class="ml-2 p-1 text-sm bg-gray-100 hover:bg-gray-200 rounded"
              (click)="checkFile(file)"
            >
              Check
            </button>
          </div>
        </div>

        @if (file.status === 'error' && file.errorMessage) {
        <div class="mt-2 p-2 bg-red-50 text-sm text-red-700 rounded-md">
          {{ file.errorMessage }}
        </div>
        }
      </div>
      }
    </div>
  </div>

  <!-- Logging Configuration -->
  <div class="mb-6">
    <h3 class="font-medium text-lg mb-2">Enable Verbose Logging</h3>
    <div class="p-3 border rounded-md">
      <div class="flex items-center">
        <button
          class="px-3 py-1.5 bg-gray-600 text-white font-medium rounded hover:bg-gray-700"
          (click)="toggleVerboseLogging()"
        >
          {{
            verboseLogging()
              ? "Disable Verbose Logging"
              : "Enable Verbose Logging"
          }}
        </button>
        <span class="ml-3 text-sm text-gray-600">
          {{
            verboseLogging()
              ? "Verbose logging is enabled"
              : "Enable for detailed Keycloak logs"
          }}
        </span>
      </div>

      @if (verboseLogging()) {
      <div class="mt-3 text-sm text-gray-700">
        <p>Check browser console (F12) for detailed Keycloak logs.</p>
        <p class="mt-1">Look for <code>keycloak-js</code> related messages.</p>
      </div>
      }
    </div>
  </div>

  <!-- Recommendations -->
  <div class="mt-8 p-4 bg-yellow-50 rounded-md">
    <h3 class="font-semibold text-lg text-yellow-800 mb-2">
      Troubleshooting Recommendations
    </h3>
    <ul class="list-disc ml-6 text-sm space-y-2 text-yellow-800">
      <li>
        Ensure Keycloak server is running and accessible at
        <code>http://localhost:8080</code>
      </li>
      <li>
        Verify the realm <code>ofelwin</code> exists on the Keycloak server
      </li>
      <li>
        Check that client <code>ofelwin-client-angular</code> is configured
        correctly
      </li>
      <li>
        Confirm <code>silent-check-sso.html</code> is accessible at
        <code>/assets/silent-check-sso.html</code>
      </li>
      <li>
        Verify CORS settings in Keycloak allow requests from your application
        origin
      </li>
      <li>
        Check network tab in browser developer tools for CORS or network errors
      </li>
      <li>
        Clear browser cache and cookies if authentication state is inconsistent
      </li>
    </ul>
  </div>
</div>


================================================
File: src/app/keycloak-diagnostic/keycloak-diagnostic.component.spec.ts
================================================
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { KeycloakDiagnosticComponent } from './keycloak-diagnostic.component';

describe('KeycloakDiagnosticComponent', () => {
  let component: KeycloakDiagnosticComponent;
  let fixture: ComponentFixture<KeycloakDiagnosticComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [KeycloakDiagnosticComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(KeycloakDiagnosticComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});


================================================
File: src/app/keycloak-diagnostic/keycloak-diagnostic.component.ts
================================================
// keycloak-diagnostic.component.ts
import { CommonModule } from '@angular/common';
import { HttpClient, HttpClientModule } from '@angular/common/http';
import { Component, effect, inject, OnInit, signal } from '@angular/core';
import { catchError, of, tap } from 'rxjs';
import { KeycloakWrapperService } from '../services/keycloak-wrapper.service';
interface ServerTest {
  url: string;
  description: string;
  status: 'pending' | 'success' | 'error' | 'not-started';
  errorMessage?: string;
  responseData?: any;
}

interface FileCheck {
  path: string;
  status: 'pending' | 'success' | 'error' | 'not-started';
  errorMessage?: string;
}
@Component({
  selector: 'app-keycloak-diagnostic',
  standalone: true,
  imports: [CommonModule, HttpClientModule],
  templateUrl: './keycloak-diagnostic.component.html',
})
export class KeycloakDiagnosticComponent implements OnInit {
  private http = inject(HttpClient);
  private keycloakWrapper = inject(KeycloakWrapperService);

  // Connection status signals
  private isConnectedState = signal<boolean>(false);
  private isInitializedState = signal<boolean>(false);
  private isAuthenticatedState = signal<boolean>(false);
  private connectionErrorState = signal<string | null>(null);
  private tokenExpiryState = signal<string | null>(null);
  constructor() {
    effect(() => {
      if (this.verboseLogging()) {
        console.log('Setting up Keycloak debug monitoring');

        // Setup monitoring interval
        const intervalId = setInterval(() => {
          this.updateConnectionStatus();
        }, 5000);

        // Cleanup when disabled
        return () => {
          console.log('Disabling Keycloak debug monitoring');
          clearInterval(intervalId);
        };
      }
      // Return cleanup function even when verbose logging is disabled
      return () => {};
    });
  }
  ngOnInit(): void {
    console.log('KeycloakDiagnosticComponent initialized');
    // Run initial connection status check
    this.updateConnectionStatus();

    // Ensure server test URLs are consistent
    this.serverTestsState.update((tests) =>
      tests.map((test) => {
        // Ensure Authentication Endpoint uses port 8080 consistently
        if (
          test.description === 'Authentication Endpoint' &&
          test.url.includes('localhost:8080')
        ) {
          console.log('Fixing Authentication Endpoint URL to use port 8080');
          return {
            ...test,
            url: 'http://localhost:8080/realms/ofelwin/protocol/openid-connect/auth',
          };
        }
        return test;
      })
    );
  }
  // Server tests signals
  private serverTestsState = signal<ServerTest[]>([
    {
      url: 'http://localhost:8080/realms/ofelwin/.well-known/openid-configuration',
      description: 'Realm Configuration',
      status: 'not-started',
    },
    {
      url: 'http://localhost:8080/realms/ofelwin/protocol/openid-connect/auth',
      description: 'Authentication Endpoint',
      status: 'not-started',
    },
    {
      url: 'http://localhost:8080/admin/master/console/',
      description: 'Keycloak Admin Console',
      status: 'not-started',
    },
  ]);

  // File checks signals
  private fileChecksState = signal<FileCheck[]>([
    {
      path: '/assets/silent-check-sso.html',
      status: 'not-started',
    },
  ]);

  // Fix action signals
  private ssoFixInProgressState = signal<boolean>(false);
  private lastFixMessageState = signal<string | null>(null);

  // Logging signals
  private verboseLoggingState = signal<boolean>(false);

  // Public readonly signals
  isConnected = this.isConnectedState.asReadonly();
  isInitialized = this.isInitializedState.asReadonly();
  isAuthenticated = this.isAuthenticatedState.asReadonly();
  connectionError = this.connectionErrorState.asReadonly();
  tokenExpiry = this.tokenExpiryState.asReadonly();
  serverTests = this.serverTestsState.asReadonly();
  fileChecks = this.fileChecksState.asReadonly();
  ssoFixInProgress = this.ssoFixInProgressState.asReadonly();
  lastFixMessage = this.lastFixMessageState.asReadonly();
  verboseLogging = this.verboseLoggingState.asReadonly();

  updateConnectionStatus(): void {
    this.keycloakWrapper.connectionStatus$.subscribe((status) => {
      this.isConnectedState.set(status.connected);
      this.isInitializedState.set(status.initialized);
      this.isAuthenticatedState.set(status.authenticated);
      this.connectionErrorState.set(status.error || null);

      if (status.tokenExpiresIn) {
        const expiresDate = new Date(Date.now() + status.tokenExpiresIn * 1000);
        this.tokenExpiryState.set(expiresDate.toLocaleString());
      } else {
        this.tokenExpiryState.set(null);
      }
    });
  }

  // Improved runServerTest method with better logging and CORS handling
  runServerTest(test: ServerTest): void {
    // Log the test being run
    console.log(`Starting test for: ${test.description} (${test.url})`);

    // Update test status to pending
    this.updateServerTestStatus(test.url, {
      status: 'pending',
    });

    // Make the HTTP request to test the endpoint
    this.http
      .get(test.url, {
        observe: 'response',
        // Add headers for CORS handling
        headers: {
          // No CORS headers needed - let the server handle CORS
        },
      })
      .pipe(
        tap((response) => {
          console.log(
            `Test succeeded for: ${test.description}`,
            response.status
          );
          this.updateServerTestStatus(test.url, {
            status: 'success',
            responseData: response.body,
          });
        }),
        catchError((error) => {
          console.error(`Test failed for: ${test.description}`, error);

          // Special handling for admin console which may have CORS restrictions
          if (
            test.url.includes('/admin/master/console/') &&
            error.status === 0
          ) {
            console.log('Admin console test - treating CORS error as success');
            this.updateServerTestStatus(test.url, {
              status: 'success',
              responseData: 'Admin console is available (CORS expected)',
            });
          } else {
            this.updateServerTestStatus(test.url, {
              status: 'error',
              errorMessage: this.formatError(error),
            });
          }
          return of(null);
        })
      )
      .subscribe({
        complete: () => console.log(`Test completed for: ${test.description}`),
      });
  }

  private updateServerTestStatus(
    url: string,
    updates: Partial<ServerTest>
  ): void {
    this.serverTestsState.update((tests) =>
      tests.map((test) => (test.url === url ? { ...test, ...updates } : test))
    );
  }

  checkFile(file: FileCheck): void {
    // Update file check status to pending
    this.updateFileCheckStatus(file.path, {
      status: 'pending',
    });

    // Try to fetch the file to see if it exists
    this.http
      .get(file.path, { responseType: 'text' })
      .pipe(
        tap(() => {
          this.updateFileCheckStatus(file.path, {
            status: 'success',
          });
        }),
        catchError((error) => {
          this.updateFileCheckStatus(file.path, {
            status: 'error',
            errorMessage: this.formatError(error),
          });
          return of(null);
        })
      )
      .subscribe();
  }

  private updateFileCheckStatus(
    path: string,
    updates: Partial<FileCheck>
  ): void {
    this.fileChecksState.update((files) =>
      files.map((file) => (file.path === path ? { ...file, ...updates } : file))
    );
  }

  runAllTests(): void {
    // Run all server tests
    this.serverTestsState().forEach((test) => {
      this.runServerTest(test);
    });

    // Run all file checks
    this.fileChecksState().forEach((file) => {
      this.checkFile(file);
    });

    // Update connection status
    this.updateConnectionStatus();
  }

  fixSilentCheckSso(): void {
    this.ssoFixInProgressState.set(true);
    this.lastFixMessageState.set('Creating silent-check-sso.html file...');

    // Create a blob with the silent-check-sso.html content
    const silentCheckSsoContent = `<html>
  <body>
    <script>
      parent.postMessage(location.href, location.origin);
    </script>
  </body>
</html>`;

    const blob = new Blob([silentCheckSsoContent], { type: 'text/html' });
    const fileUrl = URL.createObjectURL(blob);

    // Create a download link for the user to save the file
    const downloadLink = document.createElement('a');
    downloadLink.href = fileUrl;
    downloadLink.download = 'silent-check-sso.html';
    document.body.appendChild(downloadLink);
    downloadLink.click();
    document.body.removeChild(downloadLink);

    // Clean up
    URL.revokeObjectURL(fileUrl);

    this.lastFixMessageState.set(
      'File downloaded. Please place it in your assets folder at "src/assets/silent-check-sso.html" ' +
        "and rebuild your app. If you're using a dev server, restart it."
    );
    this.ssoFixInProgressState.set(false);

    // Re-check the file after a short delay
    setTimeout(() => {
      this.checkFile(this.fileChecksState()[0]);
    }, 5000);
  }

  clearCache(): void {
    // We can't programmatically clear the entire browser cache,
    // but we can clear localStorage and sessionStorage
    localStorage.clear();
    sessionStorage.clear();

    this.lastFixMessageState.set(
      'Browser storage cleared. For a complete reset, manually clear cookies and cache ' +
        'in your browser settings, then reload the page.'
    );
  }

  toggleVerboseLogging(): void {
    this.verboseLoggingState.update((current) => !current);

    if (this.verboseLoggingState()) {
      // Enable verbose logging
      console.info('Enabling verbose Keycloak logging');
      const keycloakInstance = this.keycloakWrapper.getKeycloakInstance();

      if (keycloakInstance) {
        // @ts-ignore - enableLogging might not be in the type definitions
        if (typeof keycloakInstance.enableLogging === 'function') {
          // @ts-ignore
          keycloakInstance.enableLogging(true);
        }

        console.info('Current Keycloak state:', {
          authenticated: keycloakInstance.authenticated,
          token: keycloakInstance.token ? 'Present (hidden)' : 'None',
          refreshToken: keycloakInstance.refreshToken
            ? 'Present (hidden)'
            : 'None',
          subject: keycloakInstance.subject || 'None',
          responseMode: keycloakInstance.responseMode || 'None',
          flow: keycloakInstance.flow || 'None',
        });
      } else {
        console.warn('Keycloak instance not available');
      }
    } else {
      // Disable verbose logging
      const keycloakInstance = this.keycloakWrapper.getKeycloakInstance();

      if (keycloakInstance) {
        // @ts-ignore - enableLogging might not be in the type definitions
        if (typeof keycloakInstance.enableLogging === 'function') {
          // @ts-ignore
          keycloakInstance.enableLogging(false);
        }
      }
    }
  }

  private formatError(error: any): string {
    if (!error) return 'Unknown error';

    const parts = [];

    if (error.status) {
      parts.push(`Status: ${error.status} ${error.statusText || ''}`);
    }

    if (error.message) {
      parts.push(`Message: ${error.message}`);
    }

    if (error.url) {
      parts.push(`URL: ${error.url}`);
    }

    // For CORS errors
    if (error.name === 'HttpErrorResponse' && error.message.includes('CORS')) {
      parts.push(
        'CORS Error: The server is not allowing cross-origin requests from your application'
      );
    }

    return parts.join('\n');
  }
}


================================================
File: src/app/login/login.component.html
================================================
<!-- login.component.html -->
<div
  class="flex min-h-screen items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8"
>
  <div class="w-full max-w-md space-y-8">
    <div class="text-center">
      <h2 class="mt-6 text-3xl font-bold tracking-tight text-gray-900">
        Sign in to your account
      </h2>
      <p class="mt-2 text-sm text-gray-600">
        Enter your credentials to continue
      </p>
    </div>
    <div>
      <p>
        {{ loginForm.value | json }}
      </p>
    </div>

    <form
      [formGroup]="loginForm"
      (ngSubmit)="onSubmit()"
      class="mt-8 space-y-6"
    >
      <div class="space-y-4 rounded-md shadow-sm">
        <div>
          <label for="username" class="sr-only">Username</label>
          <input
            id="username"
            formControlName="username"
            type="text"
            autocomplete="username"
            class="relative block w-full appearance-none rounded-md border border-gray-300 px-3 py-2 text-gray-900 placeholder-gray-500 focus:border-blue-500 focus:outline-none focus:ring-blue-500 sm:text-sm"
            placeholder="Username"
          />
          @if (loginForm.get('username')?.invalid &&
          loginForm.get('username')?.touched) {
          <p class="mt-1 text-sm text-red-600">Username is required</p>
          }
        </div>

        <div>
          <label for="password" class="sr-only">Password</label>
          <input
            id="password"
            formControlName="password"
            type="password"
            autocomplete="current-password"
            class="relative block w-full appearance-none rounded-md border border-gray-300 px-3 py-2 text-gray-900 placeholder-gray-500 focus:border-blue-500 focus:outline-none focus:ring-blue-500 sm:text-sm"
            placeholder="Password"
          />
          @if (loginForm.get('password')?.invalid &&
          loginForm.get('password')?.touched) {
          <p class="mt-1 text-sm text-red-600">Password is required</p>
          }
        </div>
      </div>

      @if (errorMessage()) {
      <div class="rounded-md bg-red-50 p-4">
        <div class="flex">
          <div class="ml-3">
            <h3 class="text-sm font-medium text-red-800">Error</h3>
            <div class="mt-2 text-sm text-red-700">
              <p>{{ errorMessage() }}</p>
            </div>
          </div>
        </div>
      </div>
      }

      <div>
        <button
          type="submit"
          class="group relative flex w-full justify-center rounded-md border border-transparent bg-blue-600 py-2 px-4 text-sm font-medium text-white hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed"
        >
          @if (isLoading()) {
          <span class="absolute inset-y-0 left-0 flex items-center pl-3">
            <svg
              class="h-5 w-5 animate-spin text-white"
              xmlns="http://www.w3.org/2000/svg"
              fill="none"
              viewBox="0 0 24 24"
            >
              <circle
                class="opacity-25"
                cx="12"
                cy="12"
                r="10"
                stroke="currentColor"
                stroke-width="4"
              ></circle>
              <path
                class="opacity-75"
                fill="currentColor"
                d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
              ></path>
            </svg>
          </span>
          Signing in... } @else { Sign in }
        </button>
      </div>
    </form>
  </div>
</div>


================================================
File: src/app/login/login.component.spec.ts
================================================
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { LoginComponent } from './login.component';

describe('LoginComponent', () => {
  let component: LoginComponent;
  let fixture: ComponentFixture<LoginComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [LoginComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(LoginComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});


================================================
File: src/app/login/login.component.ts
================================================
// login.component.ts
import { CommonModule, JsonPipe } from '@angular/common';
import {
  HttpClient,
  HttpClientModule,
  HttpHeaders,
} from '@angular/common/http';
import { Component, computed, effect, inject, signal } from '@angular/core';
import {
  FormBuilder,
  FormGroup,
  ReactiveFormsModule,
  Validators,
} from '@angular/forms';
import { Router } from '@angular/router';

interface KeycloakConfig {
  url: string;
  realm: string;
  clientId: string;
}

interface LoginCredentials {
  username: string;
  password: string;
}

interface AuthResponse {
  access_token: string;
  refresh_token: string;
  expires_in: number;
  token_type: string;
}

@Component({
  selector: 'app-login',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule, HttpClientModule, JsonPipe],
  templateUrl: './login.component.html',
  styleUrl: './login.component.scss',
})
export class LoginComponent {
  private http = inject(HttpClient);
  private fb = inject(FormBuilder);
  private router = inject(Router);

  // Keycloak configuration
  private keycloakConfig: KeycloakConfig = {
    url: 'http://localhost:8080',
    realm: 'ofelwin',
    clientId: 'ofelwin-client-angular',
  };

  // Form state
  loginForm: FormGroup = this.fb.group({
    username: ['testuser', [Validators.required, Validators.minLength(1)]],
    password: ['testtest!', [Validators.required, Validators.minLength(1)]],
  });

  // UI state
  isLoading = signal<boolean>(false);
  errorMessage = signal<string | null>(null);

  // Form validity - removed updateValueAndValidity from here
  isFormValid = computed(() => {
    const form = this.loginForm;
    return (
      form.valid &&
      form.get('username')?.value?.trim().length > 0 &&
      form.get('password')?.value?.trim().length > 0
    );
  });

  constructor() {
    // Using effect to handle form disabling/enabling based on loading state
    effect(() => {
      if (this.isLoading()) {
        // Disable form while loading
        this.loginForm.disable();
      } else {
        this.loginForm.enable();
      }
    });

    // REMOVED: The problematic subscription that was causing infinite recursion
    // this.loginForm.valueChanges.subscribe(() => {
    //   this.loginForm.updateValueAndValidity();
    // });
  }

  onSubmit(): void {
    if (!this.loginForm.valid) {
      return;
    }

    this.isLoading.set(true);
    this.errorMessage.set(null);

    const credentials: LoginCredentials = this.loginForm.value;
    this.authenticate(credentials)
      .then((response) => {
        // Store tokens in localStorage or a dedicated authentication service
        localStorage.setItem('access_token', response.access_token);
        localStorage.setItem('refresh_token', response.refresh_token);

        // Navigate to protected route
        this.router.navigate(['/dashboard']);
      })
      .catch((error) => {
        console.error('Authentication failed:', error);
        this.errorMessage.set('Invalid username or password');
      })
      .finally(() => {
        this.isLoading.set(false);
      });
  }

  private async authenticate(
    credentials: LoginCredentials
  ): Promise<AuthResponse> {
    const tokenUrl = `${this.keycloakConfig.url}/auth/realms/${this.keycloakConfig.realm}/protocol/openid-connect/auth`;

    const body = new URLSearchParams();
    body.set('client_id', this.keycloakConfig.clientId);
    body.set('username', credentials.username);
    body.set('password', credentials.password);
    body.set('grant_type', 'password');

    const headers = new HttpHeaders({
      'Content-Type': 'application/x-www-form-urlencoded',
    });

    try {
      // Fixed: Using firstValueFrom instead of toPromise which is deprecated
      return (await this.http
        .post<AuthResponse>(tokenUrl, body.toString(), { headers })
        .toPromise()) as AuthResponse;
    } catch (error: unknown) {
      if (error instanceof Error) {
        throw new Error(`Authentication failed: ${error.message}`);
      } else {
        throw new Error('Authentication failed: Unknown error');
      }
    }
  }
}


================================================
File: src/app/profile/profile.component.html
================================================
<!-- profile.component.html -->
<div class="max-w-3xl mx-auto p-6">
  <!-- Header -->
  <div class="mb-8">
    <h1 class="text-3xl font-bold text-gray-900 mb-2">User Profile</h1>
    <p class="text-gray-600">Manage your account information and preferences</p>
  </div>

  <!-- Loading state -->
  @if (isLoading()) {
  <div class="flex justify-center items-center h-64">
    <div
      class="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-primary"
    ></div>
  </div>
  } @else {
  <!-- Error message -->
  @if (errorMessage()) {
  <div
    class="bg-red-100 border-l-4 border-red-500 text-red-700 p-4 mb-6"
    role="alert"
  >
    <p>{{ errorMessage() }}</p>
  </div>
  }

  <!-- Success message -->
  @if (successMessage()) {
  <div
    class="bg-green-100 border-l-4 border-green-500 text-green-700 p-4 mb-6"
    role="alert"
  >
    <p>{{ successMessage() }}</p>
  </div>
  }

  <!-- Profile information -->
  @if (userProfile()) {
  <div class="bg-white rounded-lg shadow-md overflow-hidden mb-8">
    <!-- Profile header -->
    <div class="bg-gradient-to-r from-blue-500 to-indigo-600 p-6">
      <div class="flex items-center">
        <div class="flex-shrink-0">
          <div
            class="h-20 w-20 rounded-full bg-white/30 flex items-center justify-center text-white text-2xl font-semibold"
          >
            {{ userProfile()?.firstName?.charAt(0) || ""
            }}{{ userProfile()?.lastName?.charAt(0) || "" }}
          </div>
        </div>
        <div class="ml-6 text-white">
          <h2 class="text-xl font-bold">{{ displayName() }}</h2>
          <p>{{ userProfile()?.email }}</p>
          <p class="text-blue-100 text-sm mt-1">
            Username: {{ userProfile()?.username }}
          </p>
        </div>
      </div>
    </div>

    <!-- Profile edit form -->
    <div class="p-6">
      <div class="flex justify-between items-center mb-6">
        <h3 class="text-lg font-medium text-gray-900">Personal Information</h3>
        <div>
          @if (isEditing()) {
          <button
            (click)="saveProfile()"
            [disabled]="!isFormValid() || isLoading()"
            class="mr-2 inline-flex items-center px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            Save Changes
          </button>
          <button
            (click)="toggleEditMode()"
            class="inline-flex items-center px-4 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
          >
            Cancel
          </button>
          } @else {
          <button
            (click)="toggleEditMode()"
            class="inline-flex items-center px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
          >
            Edit Profile
          </button>
          }
        </div>
      </div>

      <form [formGroup]="profileForm" (ngSubmit)="saveProfile()">
        <div class="grid grid-cols-1 gap-y-6 gap-x-4 sm:grid-cols-6">
          <!-- First Name -->
          <div class="sm:col-span-3">
            <label
              for="firstName"
              class="block text-sm font-medium text-gray-700"
              >First Name</label
            >
            <div class="mt-1">
              <input
                type="text"
                id="firstName"
                formControlName="firstName"
                class="shadow-sm focus:ring-indigo-500 focus:border-indigo-500 block w-full sm:text-sm border-gray-300 rounded-md"
              />
            </div>
            @if (profileForm.get('firstName')?.invalid &&
            profileForm.get('firstName')?.touched) {
            <p class="mt-2 text-sm text-red-600">First name is required</p>
            }
          </div>

          <!-- Last Name -->
          <div class="sm:col-span-3">
            <label
              for="lastName"
              class="block text-sm font-medium text-gray-700"
              >Last Name</label
            >
            <div class="mt-1">
              <input
                type="text"
                id="lastName"
                formControlName="lastName"
                class="shadow-sm focus:ring-indigo-500 focus:border-indigo-500 block w-full sm:text-sm border-gray-300 rounded-md"
              />
            </div>
            @if (profileForm.get('lastName')?.invalid &&
            profileForm.get('lastName')?.touched) {
            <p class="mt-2 text-sm text-red-600">Last name is required</p>
            }
          </div>

          <!-- Email -->
          <div class="sm:col-span-4">
            <label for="email" class="block text-sm font-medium text-gray-700"
              >Email</label
            >
            <div class="mt-1">
              <input
                type="email"
                id="email"
                formControlName="email"
                class="shadow-sm focus:ring-indigo-500 focus:border-indigo-500 block w-full sm:text-sm border-gray-300 rounded-md"
              />
            </div>
            @if (profileForm.get('email')?.invalid &&
            profileForm.get('email')?.touched) {
            <p class="mt-2 text-sm text-red-600">
              @if (profileForm.get('email')?.errors?.['required']) { Email is
              required } @else if (profileForm.get('email')?.errors?.['email'])
              { Please enter a valid email address }
            </p>
            }
          </div>

          <!-- Phone -->
          <div class="sm:col-span-4">
            <label for="phone" class="block text-sm font-medium text-gray-700"
              >Phone Number</label
            >
            <div class="mt-1">
              <input
                type="tel"
                id="phone"
                formControlName="phone"
                class="shadow-sm focus:ring-indigo-500 focus:border-indigo-500 block w-full sm:text-sm border-gray-300 rounded-md"
              />
            </div>
            @if (profileForm.get('phone')?.invalid &&
            profileForm.get('phone')?.touched) {
            <p class="mt-2 text-sm text-red-600">
              Please enter a valid phone number
            </p>
            }
          </div>
        </div>
      </form>
    </div>
  </div>

  <!-- Account Actions -->
  <div class="bg-white rounded-lg shadow-md overflow-hidden">
    <div class="p-6">
      <h3 class="text-lg font-medium text-gray-900 mb-6">Account Actions</h3>

      <div class="space-y-4">
        <div
          class="flex items-center justify-between py-4 border-b border-gray-200"
        >
          <div>
            <h4 class="text-base font-medium text-gray-900">Sign Out</h4>
            <p class="text-sm text-gray-500">Log out from all devices</p>
          </div>
          <button
            (click)="logout()"
            class="inline-flex items-center px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-red-600 hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500"
          >
            Sign Out
          </button>
        </div>

        <div
          class="flex items-center justify-between py-4 border-b border-gray-200"
        >
          <div>
            <h4 class="text-base font-medium text-gray-900">Change Password</h4>
            <p class="text-sm text-gray-500">Update your account password</p>
          </div>
          <button
            class="inline-flex items-center px-4 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
          >
            Change Password
          </button>
        </div>
      </div>
    </div>
  </div>
  } @else {
  <!-- No profile data available -->
  <div class="bg-yellow-50 border-l-4 border-yellow-400 p-4">
    <div class="flex">
      <div class="ml-3">
        <p class="text-sm text-yellow-700">
          No profile information available. Please try logging in again.
        </p>
      </div>
    </div>
  </div>
  } }
</div>


================================================
File: src/app/profile/profile.component.spec.ts
================================================
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { ProfileComponent } from './profile.component';

describe('ProfileComponent', () => {
  let component: ProfileComponent;
  let fixture: ComponentFixture<ProfileComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [ProfileComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(ProfileComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});


================================================
File: src/app/profile/profile.component.ts
================================================
// profile.component.ts
import { CommonModule } from '@angular/common';
import {
  HttpClient,
  HttpClientModule,
  HttpHeaders,
} from '@angular/common/http';
import {
  Component,
  computed,
  effect,
  inject,
  OnInit,
  signal,
} from '@angular/core';
import {
  FormBuilder,
  FormGroup,
  FormsModule,
  ReactiveFormsModule,
  Validators,
} from '@angular/forms';
import { Router } from '@angular/router';

interface KeycloakConfig {
  url: string;
  realm: string;
  clientId: string;
}

interface UserProfile {
  id: string;
  username: string;
  firstName: string;
  lastName: string;
  email: string;
  attributes?: Record<string, string[]>;
}

interface ProfileUpdateRequest {
  firstName: string;
  lastName: string;
  email: string;
  attributes?: Record<string, string[]>;
}

@Component({
  selector: 'app-profile',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule, HttpClientModule, FormsModule],
  templateUrl: './profile.component.html',
  styleUrls: ['./profile.component.scss'],
})
export class ProfileComponent implements OnInit {
  private http = inject(HttpClient);
  private fb = inject(FormBuilder);
  private router = inject(Router);

  // Keycloak configuration
  private keycloakConfig: KeycloakConfig = {
    url: 'http://localhost:8080',
    realm: 'ofelwin',
    clientId: 'ofelwin-client-angular',
  };

  // UI state
  isLoading = signal<boolean>(false);
  isEditing = signal<boolean>(false);
  errorMessage = signal<string | null>(null);
  successMessage = signal<string | null>(null);
  userProfile = signal<UserProfile | null>(null);

  // Form state
  profileForm: FormGroup = this.fb.group({
    firstName: ['', [Validators.required]],
    lastName: ['', [Validators.required]],
    email: ['', [Validators.required, Validators.email]],
    phone: ['', [Validators.pattern(/^\+?[0-9\s-()]{7,}$/)]],
  });

  // Computed properties
  isFormValid = computed(() => this.profileForm.valid);

  displayName = computed(() => {
    const profile = this.userProfile();
    if (!profile) return '';
    return `${profile.firstName} ${profile.lastName}`;
  });

  constructor() {
    effect(() => {
      if (this.isLoading()) {
        this.profileForm.disable();
      } else {
        if (this.isEditing()) {
          this.profileForm.enable();
        } else {
          this.profileForm.disable();
        }
      }
    });
  }

  ngOnInit(): void {
    this.fetchUserProfile();
  }

  fetchUserProfile(): void {
    this.isLoading.set(true);
    this.errorMessage.set(null);

    const token = localStorage.getItem('access_token');
    if (!token) {
      this.errorMessage.set('Authentication required');
      this.router.navigate(['/login']);
      return;
    }

    const headers = new HttpHeaders({
      Authorization: `Bearer ${token}`,
    });

    const accountUrl = `${this.keycloakConfig.url}/auth/realms/${this.keycloakConfig.realm}/account`;

    this.http.get<UserProfile>(`${accountUrl}`, { headers }).subscribe({
      next: (profile) => {
        this.userProfile.set(profile);
        this.updateFormWithProfile(profile);
        this.isLoading.set(false);
      },
      error: (error) => {
        console.error('Failed to fetch profile:', error);
        if (error.status === 401) {
          this.errorMessage.set('Session expired. Please login again.');
          this.router.navigate(['/login']);
        } else {
          this.errorMessage.set('Failed to load profile information');
        }
        this.isLoading.set(false);
      },
    });
  }

  updateFormWithProfile(profile: UserProfile): void {
    this.profileForm.patchValue({
      firstName: profile.firstName,
      lastName: profile.lastName,
      email: profile.email,
      phone: profile.attributes?.['phone']?.[0] || '',
    });
  }

  toggleEditMode(): void {
    if (this.isEditing()) {
      // Cancel editing - reset form to original values
      const profile = this.userProfile();
      if (profile) {
        this.updateFormWithProfile(profile);
      }
      this.isEditing.set(false);
    } else {
      // Start editing
      this.isEditing.set(true);
    }
  }

  saveProfile(): void {
    if (!this.profileForm.valid) {
      return;
    }

    this.isLoading.set(true);
    this.errorMessage.set(null);
    this.successMessage.set(null);

    const token = localStorage.getItem('access_token');
    if (!token) {
      this.errorMessage.set('Authentication required');
      this.router.navigate(['/login']);
      return;
    }

    const headers = new HttpHeaders({
      Authorization: `Bearer ${token}`,
      'Content-Type': 'application/json',
    });

    const formValues = this.profileForm.value;
    const updateData: ProfileUpdateRequest = {
      firstName: formValues.firstName,
      lastName: formValues.lastName,
      email: formValues.email,
      attributes: {
        phone: [formValues.phone],
      },
    };

    const accountUrl = `${this.keycloakConfig.url}/auth/realms/${this.keycloakConfig.realm}/account`;

    this.http.post<void>(`${accountUrl}`, updateData, { headers }).subscribe({
      next: () => {
        // Refresh profile data
        this.fetchUserProfile();
        this.successMessage.set('Profile updated successfully');
        this.isEditing.set(false);
      },
      error: (error) => {
        console.error('Failed to update profile:', error);
        if (error.status === 401) {
          this.errorMessage.set('Session expired. Please login again.');
          this.router.navigate(['/login']);
        } else {
          this.errorMessage.set('Failed to update profile information');
        }
        this.isLoading.set(false);
      },
    });
  }

  logout(): void {
    const token = localStorage.getItem('refresh_token');
    if (!token) {
      localStorage.removeItem('access_token');
      localStorage.removeItem('refresh_token');
      this.router.navigate(['/login']);
      return;
    }

    const logoutUrl = `${this.keycloakConfig.url}/auth/realms/${this.keycloakConfig.realm}/protocol/openid-connect/logout`;

    const body = new URLSearchParams();
    body.set('client_id', this.keycloakConfig.clientId);
    body.set('refresh_token', token);

    const headers = new HttpHeaders({
      'Content-Type': 'application/x-www-form-urlencoded',
    });

    this.http.post(logoutUrl, body.toString(), { headers }).subscribe({
      next: () => {
        localStorage.removeItem('access_token');
        localStorage.removeItem('refresh_token');
        this.router.navigate(['/login']);
      },
      error: () => {
        // Even if there's an error, clear tokens and redirect
        localStorage.removeItem('access_token');
        localStorage.removeItem('refresh_token');
        this.router.navigate(['/login']);
      },
    });
  }
}


================================================
File: src/app/services/keycloak-error-handler.service.spec.ts
================================================
import { TestBed } from '@angular/core/testing';

import { KeycloakErrorHandlerService } from './keycloak-error-handler.service';

describe('KeycloakErrorHandlerService', () => {
  let service: KeycloakErrorHandlerService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(KeycloakErrorHandlerService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});


================================================
File: src/app/services/keycloak-error-handler.service.ts
================================================
import { isPlatformBrowser } from '@angular/common';
import { ErrorHandler, Inject, Injectable, PLATFORM_ID } from '@angular/core';

@Injectable({
  providedIn: 'root',
})
export class KeycloakErrorHandler implements ErrorHandler {
  constructor(@Inject(PLATFORM_ID) private platformId: Object) {}

  handleError(error: any): void {
    // Handle the error differently based on environment
    if (isPlatformBrowser(this.platformId)) {
      this.handleBrowserError(error);
    } else {
      this.handleServerError(error);
    }
  }

  private handleBrowserError(error: any): void {
    // Check if it's a Keycloak-related error
    if (this.isKeycloakError(error)) {
      console.group('Keycloak Authentication Error');
      console.error(
        'An error occurred with Keycloak authentication:',
        error.message
      );

      if (error.stack) {
        console.debug('Error stack:', error.stack);
      }

      // Additional context for debugging
      console.info('Suggestions:');
      console.info(
        '- Verify Keycloak server is running at http://localhost:8080'
      );
      console.info('- Check realm and client configuration');
      console.info('- Ensure silent-check-sso.html is properly deployed');
      console.groupEnd();
    } else {
      // For non-Keycloak errors, use default handling
      console.error('Application error:', error);
    }
  }

  private handleServerError(error: any): void {
    // In SSR mode, reduce verbosity for Keycloak errors since they're expected
    if (this.isKeycloakError(error)) {
      console.error(
        'Keycloak error during SSR (expected, will be resolved on client):',
        error.message || 'Unknown Keycloak error'
      );
    } else {
      console.error('Server-side error:', error);
    }
  }

  private isKeycloakError(error: any): boolean {
    if (!error) return false;

    // Check error message for Keycloak-related keywords
    const errorString = JSON.stringify(error).toLowerCase();
    const keycloakKeywords = [
      'keycloak',
      'authentication',
      'authorize',
      'token',
      'login',
      'sso',
      'resource access',
      'unauthorized',
      'forbidden',
      'authenticated',
    ];

    return keycloakKeywords.some((keyword) => errorString.includes(keyword));
  }
}


================================================
File: src/app/services/keycloak-wrapper.service.spec.ts
================================================
import { TestBed } from '@angular/core/testing';

import { KeycloakWrapperService } from './keycloak-wrapper.service';

describe('KeycloakWrapperService', () => {
  let service: KeycloakWrapperService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(KeycloakWrapperService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});


================================================
File: src/app/services/keycloak-wrapper.service.ts
================================================
// improved-keycloak-wrapper.service.ts
import { isPlatformBrowser } from '@angular/common';
import { HttpClient } from '@angular/common/http';
import { Inject, Injectable, PLATFORM_ID } from '@angular/core';
import { KeycloakService } from 'keycloak-angular';
import { KeycloakInstance, KeycloakProfile } from 'keycloak-js';
import { BehaviorSubject, Observable, from, of } from 'rxjs';
import { catchError, map, switchMap } from 'rxjs/operators';

export interface KeycloakConnectionStatus {
  connected: boolean;
  initialized: boolean;
  authenticated: boolean;
  error?: string;
  token?: string;
  tokenExpiresIn?: number;
}

export interface KeycloakConfig {
  url: string;
  realm: string;
  clientId: string;
}

@Injectable({
  providedIn: 'root',
})
export class KeycloakWrapperService {
  private status = new BehaviorSubject<KeycloakConnectionStatus>({
    connected: false,
    initialized: false,
    authenticated: false,
  });

  public readonly connectionStatus$ = this.status.asObservable();

  // Default Keycloak configuration
  private config: KeycloakConfig = {
    url: 'http://localhost:8080',
    realm: 'ofelwin',
    clientId: 'ofelwin-client-angular',
  };

  constructor(
    private keycloak: KeycloakService,
    private http: HttpClient,
    @Inject(PLATFORM_ID) private platformId: Object
  ) {
    // Update status periodically if in browser
    if (this.isBrowser()) {
      setInterval(() => this.updateStatus(), 30000);
    }
  }

  /**
   * Check if application is running in browser environment
   */
  private isBrowser(): boolean {
    return isPlatformBrowser(this.platformId);
  }

  /**
   * Updates the current status of the Keycloak connection
   */
  updateStatus(): void {
    if (!this.isBrowser()) {
      this.status.next({
        connected: false,
        initialized: false,
        authenticated: false,
        error: 'Server-side rendering - Keycloak not available',
      });
      return;
    }

    try {
      const instance = this.keycloak.getKeycloakInstance();

      if (!instance) {
        this.status.next({
          connected: false,
          initialized: false,
          authenticated: false,
          error: 'Keycloak instance not created',
        });
        return;
      }

      // Check initialization and authentication
      const initialized = !!instance.authenticated;
      const authenticated = !!instance.authenticated;

      // Get token information if authenticated
      let token: string | undefined;
      let tokenExpiresIn: number | undefined;

      if (authenticated && instance.token) {
        token = instance.token;
        tokenExpiresIn = instance.tokenParsed?.exp
          ? instance.tokenParsed.exp - Math.floor(Date.now() / 1000)
          : undefined;
      }

      this.status.next({
        connected: true,
        initialized,
        authenticated,
        token,
        tokenExpiresIn,
      });
    } catch (error) {
      console.error('Error checking Keycloak status:', error);
      this.status.next({
        connected: false,
        initialized: false,
        authenticated: false,
        error: error instanceof Error ? error.message : String(error),
      });
    }
  }

  /**
   * Test the connection to Keycloak server
   * Returns diagnostic information
   */
  testConnection(): Observable<any> {
    if (!this.isBrowser()) {
      return of({
        success: false,
        error: 'Server-side rendering - cannot test connection',
      });
    }

    // Try to fetch the OpenID configuration
    return this.http
      .get(
        `${this.config.url}/realms/${this.config.realm}/.well-known/openid-configuration`
      )
      .pipe(
        map((response) => ({ success: true, data: response })),
        catchError((error) =>
          of({
            success: false,
            error: error.message || 'Failed to connect to Keycloak server',
            status: error.status,
            statusText: error.statusText,
          })
        )
      );
  }

  /**
   * Safely check if the user is logged in
   * Returns false in server-side rendering
   */
  isLoggedIn(): Observable<boolean> {
    if (!this.isBrowser()) {
      return of(false);
    }

    return from(Promise.resolve(this.keycloak.isLoggedIn())).pipe(
      catchError((error) => {
        console.error('Error checking login status:', error);
        return of(false);
      })
    );
  }

  /**
   * Safely get user profile
   * Returns null in server-side rendering or if errors occur
   */
  getUserProfile(): Observable<KeycloakProfile | null> {
    if (!this.isBrowser()) {
      return of(null);
    }

    return this.isLoggedIn().pipe(
      switchMap((isLoggedIn: boolean) => {
        if (!isLoggedIn) {
          return of(null);
        }
        return from(this.keycloak.loadUserProfile()).pipe(
          catchError((error) => {
            console.error('Error loading user profile:', error);
            return of(null);
          })
        );
      }),
      catchError((error) => {
        console.error('Error in getUserProfile:', error);
        return of(null);
      })
    );
  }

  /**
   * Safely get user roles
   * Returns empty array in server-side rendering or if errors occur
   */
  getUserRoles(allRoles: boolean = true): Observable<string[]> {
    if (!this.isBrowser()) {
      return of([]);
    }

    return this.isLoggedIn().pipe(
      map((isLoggedIn) => {
        if (!isLoggedIn) {
          return [];
        }

        try {
          return this.keycloak.getUserRoles(allRoles);
        } catch (error) {
          console.error('Error getting user roles:', error);
          return [];
        }
      }),
      catchError((error) => {
        console.error('Error in getUserRoles:', error);
        return of([]);
      })
    );
  }

  /**
   * Safely perform login
   * Does nothing in server-side rendering
   */
  login(options?: any): Promise<void> {
    if (!this.isBrowser()) {
      console.warn('Login attempted in SSR, ignoring');
      return Promise.resolve();
    }

    return this.keycloak
      .login(options)
      .then(() => this.updateStatus())
      .catch((error) => {
        console.error('Login error:', error);
        this.updateStatus();
        throw error;
      });
  }

  /**
   * Safely perform logout
   * Does nothing in server-side rendering
   */
  logout(redirectUri?: string): Promise<void> {
    if (!this.isBrowser()) {
      console.warn('Logout attempted in SSR, ignoring');
      return Promise.resolve();
    }

    return this.keycloak
      .logout(redirectUri)
      .then(() => this.updateStatus())
      .catch((error) => {
        console.error('Logout error:', error);
        this.updateStatus();
        throw error;
      });
  }

  /**
   * Safely check if user has a specific role
   * Returns false in server-side rendering
   */
  hasRole(role: string): Observable<boolean> {
    return this.getUserRoles().pipe(
      map((roles) => roles.some((r) => r.toLowerCase() === role.toLowerCase()))
    );
  }

  /**
   * Get the underlying Keycloak instance for advanced operations
   * Returns null in server-side rendering
   */
  getKeycloakInstance(): KeycloakInstance | null {
    if (!this.isBrowser()) {
      return null;
    }

    try {
      return this.keycloak.getKeycloakInstance();
    } catch (error) {
      console.error('Error getting Keycloak instance:', error);
      return null;
    }
  }

  /**
   * Manually initialize Keycloak with custom config
   * Useful for testing different configurations
   */
  initializeKeycloak(config?: KeycloakConfig): Promise<boolean> {
    if (!this.isBrowser()) {
      console.warn('Initialization attempted in SSR, ignoring');
      return Promise.resolve(false);
    }

    // Use provided config or fallback to default
    const keycloakConfig = config || this.config;

    try {
      return this.keycloak
        .init({
          config: {
            url: keycloakConfig.url,
            realm: keycloakConfig.realm,
            clientId: keycloakConfig.clientId,
          },
          initOptions: {
            onLoad: 'check-sso',
            silentCheckSsoRedirectUri:
              window.location.origin + '/assets/silent-check-sso.html',
            checkLoginIframe: false,
          },
          enableBearerInterceptor: true,
          bearerPrefix: 'Bearer',
          bearerExcludedUrls: ['/assets', '/public'],
        })
        .then((success) => {
          this.updateStatus();
          return success;
        })
        .catch((error) => {
          console.error('Error initializing Keycloak:', error);
          this.updateStatus();
          return false;
        });
    } catch (error) {
      console.error('Exception during Keycloak initialization:', error);
      this.updateStatus();
      return Promise.resolve(false);
    }
  }
}


================================================
File: src/app/unauthorized/unauthorized.component.html
================================================
<p>unauthorized works!</p>


================================================
File: src/app/unauthorized/unauthorized.component.spec.ts
================================================
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { UnauthorizedComponent } from './unauthorized.component';

describe('UnauthorizedComponent', () => {
  let component: UnauthorizedComponent;
  let fixture: ComponentFixture<UnauthorizedComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [UnauthorizedComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(UnauthorizedComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});


================================================
File: src/app/unauthorized/unauthorized.component.ts
================================================
import { Component, OnInit, inject, signal } from '@angular/core';
import { Router } from '@angular/router';
import { firstValueFrom } from 'rxjs';
import { KeycloakWrapperService } from '../services/keycloak-wrapper.service';

@Component({
  selector: 'app-unauthorized',
  standalone: true,
  template: `
    <div class="flex items-center justify-center min-h-screen bg-gray-100">
      <div class="p-8 bg-white shadow-lg rounded-lg max-w-md w-full">
        <div class="flex flex-col items-center">
          <div class="bg-red-100 p-3 rounded-full">
            <svg
              class="w-16 h-16 text-red-600"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
              />
            </svg>
          </div>

          <h2 class="mt-4 text-2xl font-bold text-gray-900">Access Denied</h2>
          <p class="mt-2 text-gray-600 text-center">
            You don't have permission to access this page. Please contact your
            administrator if you believe this is an error.
          </p>

          <div class="mt-6 flex space-x-4">
            <button
              (click)="goToHome()"
              class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50"
            >
              Return to Home
            </button>

            @if (!isLoggedIn()) {
            <button
              (click)="login()"
              class="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-50"
            >
              Login
            </button>
            }
          </div>
        </div>
      </div>
    </div>
  `,
})
export class UnauthorizedComponent implements OnInit {
  private router = inject(Router);
  private keycloakWrapper = inject(KeycloakWrapperService);

  isLoggedIn = signal<boolean>(false);

  ngOnInit(): void {
    this.checkLoginStatus();
  }

  async checkLoginStatus(): Promise<void> {
    try {
      // The wrapper service handles SSR detection internally
      const isLoggedIn$ = this.keycloakWrapper.isLoggedIn();
      this.isLoggedIn.set(await firstValueFrom(isLoggedIn$));
    } catch (error) {
      console.error('Error checking login status:', error);
    }
  }

  goToHome(): void {
    this.router.navigate(['/']);
  }

  login(): void {
    this.keycloakWrapper.login();
  }
}


================================================
File: src/assets/silent-check-sso.html
================================================
<html>
  <body>
    <script>
      parent.postMessage(location.href, location.origin);
    </script>
  </body>
</html>


================================================
File: src/index.html
================================================
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>AngularKeycloak</title>
  <base href="/">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
</head>
<body>
  <app-root></app-root>
</body>
</html>


================================================
File: src/main.server.ts
================================================
import { bootstrapApplication } from '@angular/platform-browser';
import { AppComponent } from './app/app.component';
import { config } from './app/app.config.server';

const bootstrap = () => bootstrapApplication(AppComponent, config);

export default bootstrap;


================================================
File: src/main.ts
================================================
import { bootstrapApplication } from '@angular/platform-browser';
import { appConfig } from './app/app.config';
import { AppComponent } from './app/app.component';

bootstrapApplication(AppComponent, appConfig)
  .catch((err) => console.error(err));


================================================
File: src/server.ts
================================================
import {
  AngularNodeAppEngine,
  createNodeRequestHandler,
  isMainModule,
  writeResponseToNodeResponse,
} from '@angular/ssr/node';
import express from 'express';
import fs from 'fs';
import { dirname, resolve } from 'node:path';
import { fileURLToPath } from 'node:url';

const serverDistFolder = dirname(fileURLToPath(import.meta.url));
const browserDistFolder = resolve(serverDistFolder, '../browser');
const assetsFolder = resolve(browserDistFolder, 'assets');

// Ensure assets folder exists
if (!fs.existsSync(assetsFolder)) {
  fs.mkdirSync(assetsFolder, { recursive: true });
}

// Create the silent-check-sso.html file if it doesn't exist
const silentCheckSsoPath = resolve(assetsFolder, 'silent-check-sso.html');
if (!fs.existsSync(silentCheckSsoPath)) {
  const htmlContent = `<html>
  <body>
    <script>
      parent.postMessage(location.href, location.origin);
    </script>
  </body>
</html>`;

  fs.writeFileSync(silentCheckSsoPath, htmlContent);
  console.log('Created silent-check-sso.html file');
}

const app = express();
const angularApp = new AngularNodeAppEngine();

/**
 * Serve static files from /browser with appropriate cache headers
 */
app.use(
  express.static(browserDistFolder, {
    maxAge: '1y',
    index: false,
    redirect: false,
  })
);

/**
 * Special handling for silent-check-sso.html to ensure proper Keycloak SSO flow
 */
app.get('/assets/silent-check-sso.html', (req, res) => {
  res.sendFile(resolve(assetsFolder, 'silent-check-sso.html'));
});

/**
 * Add a keycloak.json route to serve the Keycloak configuration
 * This allows dynamic configuration without hardcoding values
 */
app.get('/keycloak.json', (req, res) => {
  res.json({
    realm: 'ofelwin',
    'auth-server-url': 'http://localhost:8080',
    'ssl-required': 'external',
    resource: 'ofelwin-client-angular',
    'public-client': true,
    'confidential-port': 0,
  });
});

/**
 * API route for checking server status
 */
app.get('/api/status', (req, res) => {
  res.json({ status: 'ok', timestamp: new Date().toISOString() });
});

/**
 * Handle all other requests by rendering the Angular application
 */
app.use('/**', (req, res, next) => {
  // Skip SSR for these routes related to authentication flow
  const skipSsrRoutes = ['/silent-check-sso.html', '/keycloak'];
  if (skipSsrRoutes.some((route) => req.url.includes(route))) {
    return res.sendFile(resolve(browserDistFolder, 'index.html'));
  }

  // Handle normal SSR routes
  angularApp
    .handle(req)
    .then((response) =>
      response ? writeResponseToNodeResponse(response, res) : next()
    )
    .catch((err) => {
      console.error('SSR Error:', err);
      // Fall back to serving the index.html in case of SSR errors
      res.sendFile(resolve(browserDistFolder, 'index.html'));
    });
});

/**
 * Error handler
 */
app.use(
  (
    err: any,
    req: express.Request,
    res: express.Response,
    next: express.NextFunction
  ) => {
    console.error('Server error:', err);
    res.status(500).send('Server Error');
  }
);

/**
 * Start the server if this module is the main entry point
 */
if (isMainModule(import.meta.url)) {
  const port = process.env['PORT'] || 4000;
  app.listen(port, () => {
    console.log(`Node Express server listening on http://localhost:${port}`);
  });
}

/**
 * Request handler used by the Angular CLI or Firebase Cloud Functions
 */
export const reqHandler = createNodeRequestHandler(app);


================================================
File: src/styles.scss
================================================
/* You can add global styles to this file, and also import other style files */
@use "tailwindcss";


================================================
File: tsconfig.app.json
================================================
/* To learn more about Typescript configuration file: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html. */
/* To learn more about Angular compiler options: https://angular.dev/reference/configs/angular-compiler-options. */
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "./out-tsc/app",
    "types": [
      "node"
    ]
  },
  "files": [
    "src/main.ts",
    "src/main.server.ts",
    "src/server.ts"
  ],
  "include": [
    "src/**/*.d.ts"
  ]
}


================================================
File: tsconfig.json
================================================
/* To learn more about Typescript configuration file: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html. */
/* To learn more about Angular compiler options: https://angular.dev/reference/configs/angular-compiler-options. */
{
  "compileOnSave": false,
  "compilerOptions": {
    "outDir": "./dist/out-tsc",
    "strict": true,
    "noImplicitOverride": true,
    "noPropertyAccessFromIndexSignature": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "skipLibCheck": true,
    "isolatedModules": true,
    "esModuleInterop": true,
    "experimentalDecorators": true,
    "moduleResolution": "bundler",
    "importHelpers": true,
    "target": "ES2022",
    "module": "ES2022"
  },
  "angularCompilerOptions": {
    "enableI18nLegacyMessageIdFormat": false,
    "strictInjectionParameters": true,
    "strictInputAccessModifiers": true,
    "strictTemplates": true
  }
}


================================================
File: tsconfig.spec.json
================================================
/* To learn more about Typescript configuration file: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html. */
/* To learn more about Angular compiler options: https://angular.dev/reference/configs/angular-compiler-options. */
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "./out-tsc/spec",
    "types": [
      "jasmine"
    ]
  },
  "include": [
    "src/**/*.spec.ts",
    "src/**/*.d.ts"
  ]
}

